\subsubsection{prim(stl)最小生成树}
\begin{verbatim}
const int MAXN = 2000; //number of vertices
const int INF = 2000000000; //max weight

vector < pair<int, int> > edge[MAXN];
int dist[MAXN];
bool used[MAXN];
int N;

void Prim() {
	priority_queue < pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > > Q;
	memset(used, 0, sizeof(used));
	for (int i = 0; i < N; ++i) dist[i] = INF;
	dist[0] = 0; Q.push( make_pair(0, 0) );
	while (!Q.empty()) {
		int u = Q.top().second, d = Q.top().first;
		Q.pop();
		used[u] = 1;
		if (d > dist[u]) continue;
		for (int i = 0; i < edge[u].size(); ++i) {
			int v = edge[u][i].first, w = edge[u][i].second;
			if (w < dist[v]) {
				dist[v] = w;
				Q.push( make_pair(dist[v], v) );
			}
		}
	}
}
\end{verbatim}
